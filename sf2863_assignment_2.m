birthdate = 20030110   % Write the birth date on format yyyymmdd for oldest member in the group
format compact
[lambdavec,Tvec,cvec] = getSPOdata(birthdate)   %yyyymmdd  Do not use clear command or change the values of these variables

% -------------------------------------------------------------------------------------------------------------------



% Question 2 should described in the report, and submitted below
% Enter on the format EBO2 = [EBO_1(2) EBO_2(2) ... EBO_9(2)]     
% EBO_j(2) should be the EBO for two spares of LRU2
% Cost2 should be the total cost for the allocation of spares (scalar)
EBO2 = [0.006281 0.0077829 0.05085 0.3341 0.009415 0.1295 0.87767 0.004278 0.00151]
Cost2 = 536

Q2 = [EBO2 Cost2]; % Checking both at the same time in grader.


% Question 3, you should describe how the Marginal allocation is
% implemented in your own words in the report, and compute all efficient
% points.


% Question 4 should be answered in the report, with a figure and a table with
% all efficient points
% Furthermore, a table with first five efficient points should be submitted below
% Enter on the format EPtable = [ x0 EBO(x0) C(x0); x1 EB0(x1) C(x1); ... x4 EBO(x4) C(x4)]
% Where xj is the row vector with number of spare parts of each kind
% corresponding to the efficient points generated by the Marginal allocation algorithm
% EBO and C are the total values (scalars) for each allocation xj
% Precompute EBO table: Rows = Spare levels (0 to max_s), Columns = LRU types
N = 9
max_s = 10; % Maximum number of spares to consider (can be adjusted)
EBO_table = zeros(max_s + 1, N); % Rows: spare levels, Columns: LRU types

for n = 1:N
   lambda_T = lambdavec(n) * Tvec(n); % Effective failure rate for LRU type n
   max_k = max_s + 20; % Extend beyond spares to capture tail probabilities

   % Compute Poisson probabilities p(k)
   p = zeros(1, max_k + 1);
   p(1) = exp(-lambda_T); % p(0)
   for k = 1:max_k
       p(k + 1) = (lambda_T / k) * p(k);
   end

   % Compute EBO for each spare level (0 to max_s)
   for s = 0:max_s
       EBO_s = 0;
       for k = s + 1:max_k
           EBO_s = EBO_s + (k - s) * p(k + 1);
       end
       EBO_table(s + 1, n) = EBO_s; % Store in table (row = spare level, col = LRU type)
   end
end

% Print the EBO table
%disp('EBO Table (rows = spare levels, columns = LRU types):');
%disp(EBO_table);


EPtable = [
   [0, 0, 0, 0, 0, 0, 0, 0, 0], 7.6544, 0;   
   [0, 0, 0, 1, 0, 0, 0, 0, 0], 6.8532, 22;   % Iteration 1
   [0, 0, 0, 1, 1, 0, 0, 0, 0], 6.5168, 34;   % Iteration 2
   [0, 0, 1, 1, 1, 0, 0, 0, 0], 5.9842, 56;   % Iteration 3
   [1, 0, 1, 1, 1, 0, 0, 0, 0], 5.6852, 69;   % Iteration 4

];

disp(EPtable);

% Question 5 should be discussed in the report

% You may use the commands below as a template to plot the figures.
% fig1 = figure(1)
% plot(total_cost,EBO_expect,'.-k','LineWidth',2,'MarkerSize',20)
% hold on   % Keeps old plots and adds new plots on top of the old
% hold off  % Replaces old plots with the new one
% grid on
% set(gca,'FontSize',20,'TickLabelInterpreter','latex')
% xlabel("Total Cost [-]",'FontSize',20,'interpreter','latex')
% ylabel("EBO [-]",'FontSize',20,'interpreter','latex')
% title('Efficient Solutions Curve','FontSize',20,'interpreter','latex')
% print(fig1, '-dpdf', 'myfigure.pdf'); % save to the 'myfigure.pdf' file

% Data for efficient frontier from Question 3
efficient_cost = [22, 34, 56, 69, 91, 107, 152, 231, 253, 332, 355, 377, 413, 458];
efficient_EBO = [6.85, 6.51, 5.98, 5.68, 5.21, 4.89, 4.22, 3.30, 3.08, 2.37, 2.17, 2.00, 1.73, 1.43];

% Data for Question 2 solution
Q2_cost = 536; % Total cost for 2 spares each
Q2_EBO = 1.4214; % Total EBO for 2 spares each

% Data for efficient frontier from Question 3
efficient_cost = [22, 34, 56, 69, 91, 107, 152, 231, 253, 332, 355, 377, 413, 458];
efficient_EBO = [6.85, 6.51, 5.98, 5.68, 5.21, 4.89, 4.22, 3.30, 3.08, 2.37, 2.17, 2.00, 1.73, 1.43];

% Data for Question 2 solution
Q2_cost = 536; % Total cost for 2 spares each
Q2_EBO = 1.4214; % Total EBO for 2 spares each

% Plot the efficient frontier (Question 3)
fig1 = figure(1);
plot(efficient_cost, efficient_EBO, '.-k', 'LineWidth', 2, 'MarkerSize', 20); % Efficient solutions
hold on;

% Add the Q2 solution (Question 2)
plot(Q2_cost, Q2_EBO, 'ob', 'MarkerSize', 10, 'LineWidth', 2); % Q2 point

% Enhance the graph
grid on;
set(gca, 'FontSize', 20, 'TickLabelInterpreter', 'latex');
xlabel("Total Cost [-]", 'FontSize', 20, 'Interpreter', 'latex');
ylabel("EBO [-]", 'FontSize', 20, 'Interpreter', 'latex');
title('Efficient Solutions Curve', 'FontSize', 20, 'Interpreter', 'latex');

% Add legend for clarity
legend('Efficient Frontier (Q3)', 'Q2 Solution', ...
      'FontSize', 16, 'Interpreter', 'latex', 'Location', 'northeast');

% Save the figure as a PDF
print(fig1, '-dpdf', 'Q3_and_Q2_Comparison.pdf'); % Save the figure


% -------------------------------------------------------------------------------------------------------------------



% Question 7 should be answered in the report, and submitted below
% as a row vector with numbers of LRU1 used for budget 0 to 50.

% Initialize the LRU1 vector
Cbudget_max = 50; % Maximum budget
cost_LRU1 = cvec(1); % Cost of one LRU1 spare part from the cvec array
LRU1 = zeros(1, Cbudget_max + 1); % Row vector for LRU1 allocations (budgets 0 to 50)

% Compute allocation for each budget
for budget = 0:Cbudget_max
   LRU1(budget + 1) = floor(budget / cost_LRU1); % Allocate spares based on budget
end

% Return LRU1
disp('LRU1 allocation:');
disp(LRU1);

% Question 8 should be answered in the report, and submitted below
% Enter on the format DynPtable = [ x0 EBO(x0) C(x0); x1 EB0(x1) C(x1); ... x4 EBO(x4) C(x4)]
% Where x0 to x4 are the row vectors with number of spare parts of each kind
% corresponding to the points optimal for budgets 0,100,150, 350, 500.

% Given data and parameters
Cbudget_values = [0, 100, 150, 350, 500]; % Budgets to consider
N = 9; % Number of LRU types

% Initialize DP array, where dp(n, budget) will hold the minimum EBO for LRU n with a given budget
dp = inf(N + 1, Cbudget_values(end) + 1); % Create a DP table with dimensions (N+1) x (Cbudget+1)
dp(1, :) = 0; % Base case: no backorders if no LRUs are considered

% Fill the DP table
for n = 1:N
   for budget = 0:Cbudget_values(end) % Go through all possible budgets
       for x = 0:min(floor(budget / cvec(n)), max_s) % Consider all possible quantities of spare parts to buy, constrained by max_s
           new_budget = budget - x * cvec(n); % Remaining budget after purchasing x spares
           if new_budget >= 0 && new_budget <= Cbudget_values(end) % Ensure new_budget is within valid bounds
               dp(n + 1, budget + 1) = min(dp(n + 1, budget + 1), dp(n, new_budget + 1) + EBO_table(x + 1, n));
           end
       end
   end
end

% Output table: DynPtable = [allocation EBO total_cost]
DynPtable = [];

for budget = Cbudget_values
   % Initialize allocation vector for this budget
   x_allocation = zeros(1, N); % This is the vector [x1, x2, ..., x9]
   total_cost = 0;
   total_ebo = 0;
  
   remaining_budget = budget;
  
   % Trace back the optimal allocation
   for n = N:-1:1
       for x = 0:min(floor(remaining_budget / cvec(n)), max_s) % Find the number of spares bought
           if dp(n + 1, remaining_budget + 1) == dp(n, remaining_budget + 1 - x * cvec(n)) + EBO_table(x + 1, n)
               x_allocation(n) = x; % Allocate x spares for this LRU type
               total_ebo = total_ebo + EBO_table(x + 1, n); % Add EBO for this LRU type
               total_cost = total_cost + x * cvec(n); % Add cost for this LRU type
               remaining_budget = remaining_budget - x * cvec(n);
               break;
           end
       end
   end
  
   % Store the results in DynPtable with the required format
   DynPtable = [DynPtable; x_allocation, total_ebo, total_cost];
end

% Display the results in the desired format
disp('Dynamic Programming Table (DynPtable):');
disp('Each row corresponds to a budget: [allocation EBO total_cost]');
for i = 1:size(DynPtable, 1)
   allocation_str = sprintf('[%s]', num2str(DynPtable(i, 1:N)));
   ebo_str = num2str(DynPtable(i, N + 1)); % EBO
   cost_str = num2str(DynPtable(i, N + 2)); % Total cost
   fprintf('%-25s %-10s %-10s\n', allocation_str, ebo_str, cost_str);
end

% Given data and parameters
Cbudget_values = 0:500; % Budgets from 0 to 500
max_s = 5; % Maximum spare levels
N = 9; % Number of LRU types

% Initialize DP array, where dp(n, budget) will hold the minimum EBO for LRU n with a given budget
dp = inf(N + 1, Cbudget_values(end) + 1); % Create a DP table with dimensions (N+1) x (Cbudget+1)
dp(1, :) = 0; % Base case: no backorders if no LRUs are considered

% Fill the DP table by considering LRUs from 1 to N (LRU1 to LRU9)
for n = 1:N
   for budget = 0:Cbudget_values(end) % Go through all possible budgets
       for x = 0:min(floor(budget / cvec(n)), max_s) % Consider all possible quantities of spare parts to buy, constrained by max_s
           new_budget = budget - x * cvec(n); % Remaining budget after purchasing x spares
           if new_budget >= 0 && new_budget <= Cbudget_values(end) % Ensure new_budget is within valid bounds
               dp(n + 1, budget + 1) = min(dp(n + 1, budget + 1), dp(n, new_budget + 1) + EBO_table(x + 1, n));
           end
       end
   end
end

% Arrays to store allocations, EBOs, and costs for each budget
allocations = zeros(length(Cbudget_values), N);  % Allocation for each LRU type at each budget
EBOs = zeros(length(Cbudget_values), 1);         % Total EBO for each budget
costs = zeros(length(Cbudget_values), 1);        % Total cost for each budget

% Output table: DynPtable = [allocation EBO total_cost]
main_DynPtable = [];

for idx_budget = 1:length(Cbudget_values)
   budget = Cbudget_values(idx_budget);  % Current budget
   % Initialize allocation vector for this budget
   x_allocation = zeros(1, N); % This is the vector [x1, x2, ..., x9]
   total_cost = 0;
   total_ebo = 0;
  
   remaining_budget = budget;
  
   % Trace back the optimal allocation starting from the last LRU
   for n = N:-1:1
       for x = 0:min(floor(remaining_budget / cvec(n)), max_s) % Find the number of spares bought
           if dp(n + 1, remaining_budget + 1) == dp(n, remaining_budget + 1 - x * cvec(n)) + EBO_table(x + 1, n)
               x_allocation(n) = x; % Allocate x spares for this LRU type
               total_ebo = total_ebo + EBO_table(x + 1, n); % Add EBO for this LRU type
               total_cost = total_cost + x * cvec(n); % Add cost for this LRU type
               remaining_budget = remaining_budget - x * cvec(n);
               break;
           end
       end
   end
  
   % Store the results in DynPtable
   main_DynPtable = [main_DynPtable; x_allocation, total_ebo, total_cost];
  
   % Store the allocation, EBO, and cost for plotting
   allocations(idx_budget, :) = x_allocation;
   EBOs(idx_budget) = total_ebo;
   costs(idx_budget) = total_cost;
end

% Only display results for the specified budgets: 0, 100, 150, 350, 500
display_budgets = [0, 100, 150, 350, 500];
DynPtable = main_DynPtable(ismember(Cbudget_values, display_budgets), :);

% Display the results for the specified budgets
disp('Dynamic Programming Table (DynPtable) for specified budgets:');
disp('Each row corresponds to a budget: [allocation EBO total_cost]');
for i = 1:size(DynPtable, 1)
   allocation_str = sprintf('[%s]', num2str(DynPtable(i, 1:N)));
   ebo_str = num2str(DynPtable(i, N + 1)); % EBO
   cost_str = num2str(DynPtable(i, N + 2)); % Total cost
   fprintf('%-25s %-10s %-10s\n', allocation_str, ebo_str, cost_str);
end

% Question 9 should be answered in the report

% Plot EBO vs Cost for all budgets (0 to 500)
figure;
plot(costs, EBOs, '-o');
xlabel('Total Cost');
ylabel('Total EBO');
title('EBO vs Cost for different Budgets');
grid on;

% Question 10 should be answered in the report, and submitted below
NumberOfConfigurations = 6^9
